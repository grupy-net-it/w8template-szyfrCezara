<?xml version="1.0"?>
<doc>
    <assembly>
        <name>StyleMVVM.CSharp</name>
    </assembly>
    <members>
        <member name="M:StyleMVVM.Data.Activation.IActivationServiceExtensions.Create``1(StyleMVVM.Data.Activation.IActivationService,System.Object[])">
            <summary>
            Creates a new instance of T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="activationService"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.Data.Activation.IActivationServiceExtensions.DeepClone``1(StyleMVVM.Data.Activation.IActivationService,``0)">
            <summary>
            Creates a deep clone of the specified object.
            </summary>
            <typeparam name="T">Type of object to clone</typeparam>
            <param name="activationService"> </param>
            <param name="value">object to clone</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.Data.Activation.IActivationServiceExtensions.DeepCloneIntoInstance``1(StyleMVVM.Data.Activation.IActivationService,``0,``0)">
            <summary>
            Clone one object into another.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="activationService"> </param>
            <param name="value"></param>
            <param name="tInstance"></param>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.Data.Collections.ComplexDictionary`2">
            <summary>
            This is a TODO
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="T:StyleMVVM.Data.EditableDataWrapper`1">
            <summary>
            A utiltity class that wraps a value of type T and records edits for an object
            </summary>
            <typeparam name="T">data object type to wrap</typeparam>
        </member>
        <member name="T:StyleMVVM.Data.NotifyObject">
            <summary>
            A base object that implements INotifyPropertyChanged and offers logging
            </summary>
        </member>
        <member name="M:StyleMVVM.Data.NotifyObject.SetProperty``1(``0@,``0,System.String)">
            <summary>
            Sets a value to a particular property while calling PropertyChanged
            Note: Default implementation from VS temlate
            </summary>
            <typeparam name="T">type of property</typeparam>
            <param name="storage">backing field for the property</param>
            <param name="value">new value to set</param>
            <param name="propertyName">property name (usually left blank if calling from property)</param>
            <returns>true if the value was set (false if its the same value)</returns>
        </member>
        <member name="M:StyleMVVM.Data.NotifyObject.OnPropertyChanged(System.String)">
            <summary>
            Default implementation of Propertychanged event invoker
            </summary>
            <param name="propertyName">property that changed</param>
        </member>
        <member name="T:StyleMVVM.Data.IEditableDataWrapper`1">
            <summary>
            Interface that wraps a data object and tracks changes
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:StyleMVVM.Data.IEditable">
            <summary>
            Interface representing basic Commit/RollBack functionality
            </summary>
        </member>
        <member name="M:StyleMVVM.Data.IEditable.Commit">
            <summary>
            Commit the edits to the object
            </summary>
        </member>
        <member name="M:StyleMVVM.Data.IEditable.RollBack">
            <summary>
            Rollback the dits to the object
            </summary>
        </member>
        <member name="P:StyleMVVM.Data.IEditable.PendingChanges">
            <summary>
            True if the object has any pending changes
            </summary>
        </member>
        <member name="P:StyleMVVM.Data.IEditable.EditingMode">
            <summary>
            What editing mode is this object in
            </summary>
        </member>
        <member name="P:StyleMVVM.Data.IEditableDataWrapper`1.Value">
            <summary>
            Value to wrap (this object can be changed over the lifetime of the wrapper)
            </summary>
        </member>
        <member name="T:StyleMVVM.Data.IMergable">
            <summary>
            This is for future use. 
            </summary>
        </member>
        <member name="T:StyleMVVM.Data.Transform.TransformAttribute">
            <summary>
            Using this attribute on a property will change the name that the property
            Maps out to in transfermation
            </summary>
        </member>
        <member name="M:StyleMVVM.Data.WeakNotifyObject.SetProperty``1(``0@,``0,System.String)">
            <summary>
            Sets a value to a particular property while calling PropertyChanged
            Note: Default implementation from VS temlate
            </summary>
            <typeparam name="T">type of property</typeparam>
            <param name="storage">backing field for the property</param>
            <param name="value">new value to set</param>
            <param name="propertyName">property name (usually left blank if calling from property)</param>
            <returns>true if the value was set (false if its the same value)</returns>
        </member>
        <member name="M:StyleMVVM.Data.WeakNotifyObject.OnPropertyChanged(System.String)">
            <summary>
            Default implementation of Propertychanged event invoker
            </summary>
            <param name="propertyName">property that changed</param>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.ActivationCompleteAttribute">
            <summary>
            Attribute that goes onto a method with no parameters in a class that is being exported.
            The action will be called as the last step of activation.
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.CachedAttribute">
            <summary>
            Exported classes that use this attribute will be cached in the DI container and reused till the cache time expires
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.CachedAttribute.ExpirationTime">
            <summary>
            Allows you to control the length of time this component will be cached (15 min by default)
            Note: this string will be passed into a timespan so formats like "00:15:00" are expected
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.CachedAttribute.SlidingExpireWindow">
            <summary>
            The cache window will be extended each time you access the object if true (true by default)
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.CoreExportAttribute">
            <summary>
            Classes attributed with this will be created at startup
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.DesignTimeOnlyAttribute">
            <summary>
            This denotes the type should only be load at During design time
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.ExportEnvironmentAttribute">
            <summary>
            This attribute allows you to dictate what environment to export the class in.
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.ExportAttribute">
            <summary>
            Use this attribute on the top of a class you want to export to the DI container
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.ExportAttribute.#ctor">
            <summary>
            Exports as the name of the Class with no namespace
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.ExportAttribute.#ctor(System.Type,System.Type[])">
            <summary>
             Exports as the FullName of the Type
            </summary>
            <param name="type"></param>
            <param name="types"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.ExportAttribute.#ctor(System.String,System.String[])">
            <summary>
            Exports the type as exportName
            </summary>
            <param name="exportName"></param>
            <param name="names"></param>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.ExportAttribute.ExportTypes">
            <summary>
            Exported Types for this type
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.ExportAttribute.ExportNames">
            <summary>
            Exported Name for this type
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.ExportByInterfacesAttribute">
            <summary>
            This attribute allows you to tell the DI container that you would like to export this type by all the interfaces it implements
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:StyleMVVM.DependencyInjection.ExportByInterfacesAttribute.SkipMicrosoftInterfaces" -->
        <member name="T:StyleMVVM.DependencyInjection.IExportConfiguration`1">
            <summary>
            This interface represents a generic way to configure a Type export
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Export the type with the specified priority
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration`1.As``1">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <typeparam name="TExportType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration`1.InEnvironment(StyleMVVM.DependencyInjection.ExportEnvironment)">
            <summary>
            Export type in this Environment (ExportEnvironement is a flag so it can be or'd)
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration`1.AsName(System.String)">
            <summary>
            Export the type under the specified name
            </summary>
            <param name="name">name to export under</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration`1.AndShared">
            <summary>
            Share this export between all callers (can be garbage collected)
            </summary>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration`1.AndSharedPermenantly">
            <summary>
            Share this export permanently 
            </summary>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration`1.AndCachedWithAbsoluteExpiration(System.TimeSpan)">
            <summary>
            Allows you to mark this export to be cached using an absolute expire time after creation
            </summary>
            <param name="timeSpan"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration`1.AndCachedWithSlidingExpiration(System.TimeSpan)">
            <summary>
            Allows you to mark this export to be cached using a sliding expiration time
            </summary>
            <param name="timeSpan"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration`1.CoreExport(StyleMVVM.DependencyInjection.CoreExportStartOrder)">
            <summary>
            Mark this export as a core export (created up container startup)
            </summary>
            <param name="startOrder"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration`1.ImportConstructor(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            This mthod allows you to specify which constructor to use ( x => new MyTypeName("Specific","Constructor") )
            </summary>
            <param name="constructorExpression">constructor expression ( x => new MyTypeName("Specific","Constructor") )</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration`1.InitializeProperty(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Mark a specific property to be initialized (a new object constructed and set to property)
            </summary>
            <param name="property">property expression ( x => x.PropertyName )</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration`1.InitializeProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
            <summary>
            Mark a specific property to be initialized (a new object constructed and set to property)
            </summary>
            <param name="property">property expression ( x => x.PropertyName )</param>
            <param name="initializeValue">initialize value</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration`1.ImportProperty(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Boolean,System.String)">
            <summary>
            Mark a property for Import (using dependency injection container)
            </summary>
            <param name="property">property expression (x => x.PropertyName) </param>
            <param name="isRequired">is the import required (object will not construct if true and cannot be found)</param>
            <param name="exportName">export name to use (when null it will use the property type to locate the export)</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration`1.ImportMethod(System.Linq.Expressions.Expression{System.Action{`0}},System.Boolean,System.String)">
            <summary>
            Mark a method to be called upon activation passing in an arguement that has be located using the IoC
            </summary>
            <param name="property"></param>
            <param name="isRequired"></param>
            <param name="exportName"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration`1.ActivationMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Mark a particular Action() as the activation action
            </summary>
            <param name="activationMethod"></param>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.ExportPriorityAttribute">
            <summary>
            This attribute allows you to specify what priority to export this attribute at. 
            Note: Environment is used before priority when it comes time to sort exports.
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.ExportPriorityAttribute.Priority">
            <summary>
            The Export Priority
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.IDependencyInjectionContainerExtension">
            <summary>
            C# extensions for IDependencyInjectionContainer
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainerExtension.Locate``1(StyleMVVM.DependencyInjection.IDependencyInjectionContainer,System.Object[])">
            <summary>
            Locate an export based upon type
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <param name="container">container to locate from</param>
            <param name="parameters">parameters to pass upon construction</param>
            <returns>located type</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainerExtension.LocateAll``1(StyleMVVM.DependencyInjection.IDependencyInjectionContainer)">
            <summary>
            Locate all exports of a particular type
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <param name="container">container to locate from</param>
            <returns>located types</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainerExtension.Register``1(StyleMVVM.DependencyInjection.IDependencyInjectionContainer)">
            <summary>
            Registers a type for export
            </summary>
            <typeparam name="T"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainerExtension.RegisterExportFunction``1(StyleMVVM.DependencyInjection.IDependencyInjectionContainer,System.Func{StyleMVVM.DependencyInjection.IDependencyInjectionContainer,System.Object[],``0})">
            <summary>
            Register a new Function for export in the DI container
            </summary>
            <typeparam name="T">type the function returns</typeparam>
            <param name="container">container</param>
            <param name="exportFunction">export function</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportAssemblyConfigurationExtensions.ExportInterface``1(StyleMVVM.DependencyInjection.IExportAssemblyConfiguration)">
            <summary>
            This extension allows you export all classes implementing a specific interface in an aseembly
            </summary>
            <typeparam name="T">Interface to export</typeparam>
            <param name="exportAssemblyConfig"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportAssemblyConfigurationExtensions.Excluding``1(StyleMVVM.DependencyInjection.IExportAssemblyConfiguration)">
            <summary>
            This extension allows you to exclude a particular type from export
            </summary>
            <typeparam name="T"></typeparam>
            <param name="exportAssemblyConfig"></param>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.ImportAttribute">
            <summary>
            This attribute is meant to go on public properties and denotes that 
            as part of activation process this property should be populated from the container
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.ImportAttribute.ImportName">
            <summary>
            This is the name to use when resolving an import. when null the type of the property is used for Dependency Injection location
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.ImportAttribute.Required">
            <summary>
            If true then construction will fail if import cannot be found. (true by default)
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.ImportConstructorAttribute">
            <summary>
            This attribute marks a constructor for use in object construction
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.ImportMethodAttribute">
            <summary>
            Use this attribute to designate a method to be called at activation time to inject services.
            Each parameter to the method will be resolved using the DI container, you can have multiple methods.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:StyleMVVM.DependencyInjection.NonRunTimeExportAttribute" -->
        <member name="T:StyleMVVM.DependencyInjection.RuntimeOnlyAttribute">
            <summary>
            Use this attribute on the top of a class that you want to export only at Runtime
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.SharedAttribute">
            <summary>
            To be used on an object that is going to be shared between everyone.
            Note: You can not use constructor params on a shared service. If you do 
            you get back an instance but it will not be shared with other callers.
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.SharedAttribute.Permanent">
            <summary>
            By default this is false and should only be set to true if you want the
            shared export to be held for the lifetime of the container. 
            Services like IDispatchedMessenger and IReflectionService are true.
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.UnitTestOnlyAttribute">
            <summary>
            Use this to attribute a class as exporting only at unit test time
            </summary>
        </member>
        <member name="T:StyleMVVM.Messenger.BackgroundMessageHandlerAttribute">
            <summary>
            This attribute is to be used on a method that should be registerd
            As a background message handler.
            Note: the method should match the signature Action(T)
            </summary>
        </member>
        <member name="T:StyleMVVM.Messenger.CallbackMessage`1">
            <summary>
            This class is intended to allow a message sender to get a callback from the receiver with a return. 
            It is dispatcher aware so you will get the call back on the correct dispatcher
            </summary>
            <typeparam name="T">the message callback parameter.</typeparam>
        </member>
        <member name="M:StyleMVVM.Messenger.IDispatchedMessengerExtensions.Register``1(StyleMVVM.Messenger.IDispatchedMessenger,System.Action{``0},System.Boolean,System.Boolean)">
            <summary>
            Registers a new Action(T) handler for receiving messages of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="messenger"></param>
            <param name="action"></param>
            <param name="background"></param>
            <param name="holdReference"></param>
        </member>
        <member name="M:StyleMVVM.Messenger.IDispatchedMessengerExtensions.Unregister``1(StyleMVVM.Messenger.IDispatchedMessenger,System.Action{``0})">
            <summary>
            Unregister an Action(T) handler
            </summary>
            <typeparam name="T"></typeparam>
            <param name="messenger"></param>
            <param name="action"></param>
        </member>
        <member name="T:StyleMVVM.Messenger.MessageHandlerAttribute">
            <summary>
            This attribute is to be used on a method that should be registerd
            As a message handler.
            Note: the method should match the signature Action(T)
            </summary>
        </member>
        <member name="T:StyleMVVM.Messenger.RegisterForMessageOnActivationAttribute">
            <summary>
            Classes with this attribute will be registered for message handlers 
            at the time of creation.
            </summary>
        </member>
        <member name="T:StyleMVVM.Suspension.SuspensionManager">
            <summary>
            SuspensionManager captures global session state to simplify process lifetime management
            for an application.  Note that session state will be automatically cleared under a variety
            of conditions and should only be used to store information that would be convenient to
            carry across sessions, but that should be disacarded when an application crashes or is
            upgraded.
            </summary>
        </member>
        <member name="M:StyleMVVM.Suspension.SuspensionManager.SaveAsync">
            <summary>
            Save the current <see cref="P:StyleMVVM.Suspension.SuspensionManager.SessionState"/>.  Any <see cref="T:Windows.UI.Xaml.Controls.Frame"/> instances
            registered with <see cref="M:StyleMVVM.Suspension.SuspensionManager.RegisterFrame(Windows.UI.Xaml.Controls.Frame,System.String)"/> will also preserve their current
            navigation stack, which in turn gives their active <see cref="T:Windows.UI.Xaml.Controls.Page"/> an opportunity
            to save its state.
            </summary>
            <returns>An asynchronous task that reflects when session state has been saved.</returns>
        </member>
        <member name="M:StyleMVVM.Suspension.SuspensionManager.RestoreAsync">
            <summary>
            Restores previously saved <see cref="P:StyleMVVM.Suspension.SuspensionManager.SessionState"/>.  Any <see cref="T:Windows.UI.Xaml.Controls.Frame"/> instances
            registered with <see cref="M:StyleMVVM.Suspension.SuspensionManager.RegisterFrame(Windows.UI.Xaml.Controls.Frame,System.String)"/> will also restore their prior navigation
            state, which in turn gives their active <see cref="T:Windows.UI.Xaml.Controls.Page"/> an opportunity restore its
            state.
            </summary>
            <returns>An asynchronous task that reflects when session state has been read.  The
            content of <see cref="P:StyleMVVM.Suspension.SuspensionManager.SessionState"/> should not be relied upon until this task
            completes.</returns>
        </member>
        <member name="M:StyleMVVM.Suspension.SuspensionManager.RegisterFrame(Windows.UI.Xaml.Controls.Frame,System.String)">
            <summary>
            Registers a <see cref="T:Windows.UI.Xaml.Controls.Frame"/> instance to allow its navigation history to be saved to
            and restored from <see cref="P:StyleMVVM.Suspension.SuspensionManager.SessionState"/>.  Frames should be registered once
            immediately after creation if they will participate in session state management.  Upon
            registration if state has already been restored for the specified key
            the navigation history will immediately be restored.  Subsequent invocations of
            <see cref="M:StyleMVVM.Suspension.SuspensionManager.RestoreAsync"/> will also restore navigation history.
            </summary>
            <param name="frame">An instance whose navigation history should be managed by
            <see cref="T:StyleMVVM.Suspension.SuspensionManager"/></param>
            <param name="sessionStateKey">A unique key into <see cref="P:StyleMVVM.Suspension.SuspensionManager.SessionState"/> used to
            store navigation-related information.</param>
        </member>
        <member name="M:StyleMVVM.Suspension.SuspensionManager.UnregisterFrame(Windows.UI.Xaml.Controls.Frame)">
            <summary>
            Disassociates a <see cref="T:Windows.UI.Xaml.Controls.Frame"/> previously registered by <see cref="M:StyleMVVM.Suspension.SuspensionManager.RegisterFrame(Windows.UI.Xaml.Controls.Frame,System.String)"/>
            from <see cref="P:StyleMVVM.Suspension.SuspensionManager.SessionState"/>.  Any navigation state previously captured will be
            removed.
            </summary>
            <param name="frame">An instance whose navigation history should no longer be
            managed.</param>
        </member>
        <member name="M:StyleMVVM.Suspension.SuspensionManager.SessionStateForFrame(Windows.UI.Xaml.Controls.Frame)">
            <summary>
            Provides storage for session state associated with the specified <see cref="T:Windows.UI.Xaml.Controls.Frame"/>.
            Frames that have been previously registered with <see cref="M:StyleMVVM.Suspension.SuspensionManager.RegisterFrame(Windows.UI.Xaml.Controls.Frame,System.String)"/> have
            their session state saved and restored automatically as a part of the global
            <see cref="P:StyleMVVM.Suspension.SuspensionManager.SessionState"/>.  Frames that are not registered have transient state
            that can still be useful when restoring pages that have been discarded from the
            navigation cache.
            </summary>
            <remarks>Apps may choose to rely on <see cref="!:LayoutAwarePage"/> to manage
            page-specific state instead of working with frame session state directly.</remarks>
            <param name="frame">The instance for which session state is desired.</param>
            <returns>A collection of state subject to the same serialization mechanism as
            <see cref="P:StyleMVVM.Suspension.SuspensionManager.SessionState"/>.</returns>
        </member>
        <member name="P:StyleMVVM.Suspension.SuspensionManager.SessionState">
            <summary>
            Provides access to global session state for the current session.  This state is
            serialized by <see cref="M:StyleMVVM.Suspension.SuspensionManager.SaveAsync"/> and restored by
            <see cref="M:StyleMVVM.Suspension.SuspensionManager.RestoreAsync"/>, so values must be serializable by
            <see cref="T:System.Runtime.Serialization.DataContractSerializer"/> and should be as compact as possible.  Strings
            and other self-contained data types are strongly recommended.
            </summary>
        </member>
        <member name="M:StyleMVVM.Utilities.GenericWeakAction`1.#ctor(System.Action{`0},System.Boolean)">
            <summary>
            Use this method if you want to create a compiled linq accessor. 
            Its a slight penalty up front but is much faster if you call it alot.
            </summary>
            <param name="action"></param>
            <param name="compiledAccessor"></param>
        </member>
        <member name="M:StyleMVVM.Utilities.GenericWeakAction`2.#ctor(System.Action{`0,`1},System.Boolean)">
            <summary>
            Use this method if you want to create a compiled linq accessor. 
            Its a slight penalty up front but is much faster if you call it alot.
            </summary>
            <param name="action"></param>
            <param name="compiledAccessor"></param>
        </member>
        <member name="M:StyleMVVM.Utilities.GenericWeakAction`2.#ctor(System.Delegate)">
            <summary>
            Use this method if you want to create a compiled linq accessor. 
            Its a slight penalty up front but is much faster if you call it alot.
            </summary>
            <param name="action"></param>
            <param name="compiledAccessor"></param>
        </member>
        <member name="M:StyleMVVM.Utilities.GenericWeakAction`2.#ctor(System.Delegate,System.Boolean)">
            <summary>
            Use this method if you want to create a compiled linq accessor. 
            Its a slight penalty up front but is much faster if you call it alot.
            </summary>
            <param name="action"></param>
            <param name="compiledAccessor"></param>
        </member>
        <member name="T:StyleMVVM.Utilities.SerializationHelper">
            <summary>
            This class contains generic methods to serialize and deserialize objects to files
            </summary>
        </member>
        <member name="M:StyleMVVM.Validation.Impl.Fluent.FluentRuleBuilder`1.CreateTestStatements(Windows.ApplicationModel.Resources.ResourceLoader,StyleMVVM.Validation.Impl.Fluent.FluentPropertyExpressionProvider{`0},System.Nullable{System.Boolean},System.Collections.Generic.List{StyleMVVM.Validation.Impl.Fluent.IFluentOperator{`0}},System.String@)">
            <summary>
            Create the statement to be used in an If statement, it does not flag any errors
            </summary>
            <param name="fluentResources"></param>
            <param name="expressionProvider"></param>
            <param name="andOrLogic"></param>
            <param name="logicBlocks"></param>
            <param name="logicMessage"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.Validation.Impl.Fluent.FluentRuleBuilder`1.CreateErrorCaseStatements(Windows.ApplicationModel.Resources.ResourceLoader,StyleMVVM.Validation.Impl.Fluent.FluentPropertyExpressionProvider{`0},System.Nullable{System.Boolean},System.Collections.Generic.List{StyleMVVM.Validation.Impl.Fluent.IFluentOperator{`0}},System.String@)">
            <summary>
            Creates a set of statements to be used as part of the Then case or Else case of a rule.
            It will flag properties for errors 
            </summary>
            <param name="fluentResources"></param>
            <param name="expressionProvider"></param>
            <param name="andOrLogic"></param>
            <param name="logicBlocks"></param>
            <param name="errorMessage"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.Validation.Impl.Fluent.FluentRuleBuilder`1.GeneratePropertyErrorMessage(Windows.ApplicationModel.Resources.ResourceLoader,StyleMVVM.Validation.Impl.Fluent.IFluentOperator{`0},StyleMVVM.Validation.Impl.Fluent.FluentPropertyExpressionProvider{`0},System.String)">
            <summary>
            Create the statement for calling executionContext.AddError or executionContext.AddRequired
            </summary>
            <param name="fluentResources"></param>
            <param name="provider"></param>
            <param name="expressionProvider"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.ViewModel.BaseViewModel">
            <summary>
            Base View Model for Style, if you inherit from this you will inherit the ViewModel attribute and import your DI container
            </summary>
        </member>
        <member name="P:StyleMVVM.ViewModel.BaseViewModel.Container">
            <summary>
            The DI container this object should use by default
            </summary>
        </member>
        <member name="T:StyleMVVM.ViewModel.EditableDataViewModel`1">
            <summary>
            Represents a ViewModel that wraps a data value of type T.
            It automatically tracks edits and can rollback or commit to the value
            DataBinding should go directly against this data context not the Value object
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:StyleMVVM.ViewModel.EditablePageViewModel`1">
            <summary>
            Represents a Page ViewModel that wraps a data value of type T.
            It automatically tracks edits and can rollback or commit to the value
            DataBinding should go directly against this data context not the Value object
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:StyleMVVM.ViewModel.PageViewModel">
            <summary>
            This is the default implementation for ViewModels associated with a Page
            </summary>
        </member>
        <member name="T:StyleMVVM.ViewModel.RegionAwareViewModel">
            <summary>
            This is a base ViewModel designed to handle Region navigation. This is inlu 
            </summary>
        </member>
        <member name="P:StyleMVVM.ViewModel.RegionAwareViewModel.Region">
            <summary>
            This is the current region for the ViewModel. 
            It is held as a Weak reference so I do not recommend holding a strong reference to it
            That includes data binding.
            </summary>
        </member>
        <member name="T:StyleMVVM.ViewModel.ViewModelAttribute">
            <summary>
            This is meant to be attributed on classes that are viewModels
            It Exports the class under the classes Name with no namespace
            </summary>
        </member>
        <member name="T:StyleMVVM.View.LayoutAwarePage">
            <summary>
            Typical implementation of Page that provides several important conveniences:
            <list type="bullet">
            <item>
            <description>Application view state to visual state mapping</description>
            </item>
            <item>
            <description>GoBack, GoForward, and GoHome event handlers</description>
            </item>
            <item>
            <description>Mouse and keyboard shortcuts for navigation</description>
            </item>
            <item>
            <description>State management for navigation and process lifetime management</description>
            </item>
            <item>
            <description>A default view model</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="M:StyleMVVM.View.NavigatingPage.GoHome(System.Object,Windows.UI.Xaml.RoutedEventArgs)">
            <summary>
            Invoked as an event handler to navigate backward in the page's associated
            <see cref="T:Windows.UI.Xaml.Controls.Frame"/> until it reaches the top of the navigation stack.
            </summary>
            <param name="sender">Instance that triggered the event.</param>
            <param name="e">Event data describing the conditions that led to the event.</param>
        </member>
        <member name="M:StyleMVVM.View.NavigatingPage.GoBack(System.Object,Windows.UI.Xaml.RoutedEventArgs)">
            <summary>
            Invoked as an event handler to navigate backward in the navigation stack
            associated with this page's <see cref="T:Windows.UI.Xaml.Controls.Frame"/>.
            </summary>
            <param name="sender">Instance that triggered the event.</param>
            <param name="e">Event data describing the conditions that led to the
            event.</param>
        </member>
        <member name="M:StyleMVVM.View.NavigatingPage.GoForward(System.Object,Windows.UI.Xaml.RoutedEventArgs)">
            <summary>
            Invoked as an event handler to navigate forward in the navigation stack
            associated with this page's <see cref="T:Windows.UI.Xaml.Controls.Frame"/>.
            </summary>
            <param name="sender">Instance that triggered the event.</param>
            <param name="e">Event data describing the conditions that led to the
            event.</param>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwarePage.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:StyleMVVM.View.LayoutAwarePage"/> class.
            </summary>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwarePage.CoreDispatcher_AcceleratorKeyActivated(Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs)">
            <summary>
            Invoked on every keystroke, including system keys such as Alt key combinations, when
            this page is active and occupies the entire window.  Used to detect keyboard navigation
            between pages even when the page itself doesn't have focus.
            </summary>
            <param name="sender">Instance that triggered the event.</param>
            <param name="args">Event data describing the conditions that led to the event.</param>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwarePage.CoreWindow_PointerPressed(Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs)">
            <summary>
            Invoked on every mouse click, touch screen tap, or equivalent interaction when this
            page is active and occupies the entire window.  Used to detect browser-style next and
            previous mouse button clicks to navigate between pages.
            </summary>
            <param name="sender">Instance that triggered the event.</param>
            <param name="args">Event data describing the conditions that led to the event.</param>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwarePage.StartLayoutUpdates(System.Object,Windows.UI.Xaml.RoutedEventArgs)">
            <summary>
            Invoked as an event handler, typically on the <see cref="E:Windows.UI.Xaml.FrameworkElement.Loaded"/>
            event of a <see cref="T:Windows.UI.Xaml.Controls.Control"/> within the page, to indicate that the sender should
            start receiving visual state management changes that correspond to application view
            state changes.
            </summary>
            <param name="sender">Instance of <see cref="T:Windows.UI.Xaml.Controls.Control"/> that supports visual state
            management corresponding to view states.</param>
            <param name="e">Event data that describes how the request was made.</param>
            <remarks>The current view state will immediately be used to set the corresponding
            visual state when layout updates are requested.  A corresponding
            <see cref="E:Windows.UI.Xaml.FrameworkElement.Unloaded"/> event handler connected to
            <see cref="M:StyleMVVM.View.LayoutAwarePage.StopLayoutUpdates(System.Object,Windows.UI.Xaml.RoutedEventArgs)"/> is strongly encouraged.  Instances of
            <see cref="T:StyleMVVM.View.LayoutAwarePage"/> automatically invoke these handlers in their Loaded and
            Unloaded events.</remarks>
            <seealso cref="M:StyleMVVM.View.LayoutAwarePage.DetermineVisualState(Windows.UI.ViewManagement.ApplicationViewState)"/>
            <seealso cref="M:StyleMVVM.View.LayoutAwarePage.InvalidateVisualState"/>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwarePage.StopLayoutUpdates(System.Object,Windows.UI.Xaml.RoutedEventArgs)">
            <summary>
            Invoked as an event handler, typically on the <see cref="E:Windows.UI.Xaml.FrameworkElement.Unloaded"/>
            event of a <see cref="T:Windows.UI.Xaml.Controls.Control"/>, to indicate that the sender should start receiving
            visual state management changes that correspond to application view state changes.
            </summary>
            <param name="sender">Instance of <see cref="T:Windows.UI.Xaml.Controls.Control"/> that supports visual state
            management corresponding to view states.</param>
            <param name="e">Event data that describes how the request was made.</param>
            <remarks>The current view state will immediately be used to set the corresponding
            visual state when layout updates are requested.</remarks>
            <seealso cref="M:StyleMVVM.View.LayoutAwarePage.StartLayoutUpdates(System.Object,Windows.UI.Xaml.RoutedEventArgs)"/>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwarePage.DetermineVisualState(Windows.UI.ViewManagement.ApplicationViewState)">
            <summary>
            Translates <see cref="T:Windows.UI.ViewManagement.ApplicationViewState"/> values into strings for visual state
            management within the page.  The default implementation uses the names of enum values.
            Subclasses may override this method to control the mapping scheme used.
            </summary>
            <param name="viewState">View state for which a visual state is desired.</param>
            <returns>Visual state name used to drive the
            <see cref="T:Windows.UI.Xaml.VisualStateManager"/></returns>
            <seealso cref="M:StyleMVVM.View.LayoutAwarePage.InvalidateVisualState"/>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwarePage.InvalidateVisualState">
            <summary>
            Updates all controls that are listening for visual state changes with the correct
            visual state.
            </summary>
            <remarks>
            Typically used in conjunction with overriding <see cref="M:StyleMVVM.View.LayoutAwarePage.DetermineVisualState(Windows.UI.ViewManagement.ApplicationViewState)"/> to
            signal that a different value may be returned even though the view state has not
            changed.
            </remarks>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwarePage.OnNavigatedTo(Windows.UI.Xaml.Navigation.NavigationEventArgs)">
            <summary>
            Invoked when this page is about to be displayed in a Frame.
            </summary>
            <param name="e">Event data that describes how this page was reached.  The Parameter
            property provides the group to be displayed.</param>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwarePage.OnNavigatedFrom(Windows.UI.Xaml.Navigation.NavigationEventArgs)">
            <summary>
            Invoked when this page will no longer be displayed in a Frame.
            </summary>
            <param name="e">Event data that describes how this page was reached.  The Parameter
            property provides the group to be displayed.</param>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwarePage.LoadState(System.Object,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Populates the page with content passed during navigation.  Any saved state is also
            provided when recreating a page from a prior session.
            </summary>
            <param name="navigationParameter">The parameter value passed to
            <see cref="M:Windows.UI.Xaml.Controls.Frame.Navigate(System.Type,System.Object)"/> when this page was initially requested.
            </param>
            <param name="pageState">A dictionary of state preserved by this page during an earlier
            session.  This will be null the first time a page is visited.</param>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwarePage.SaveState(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Preserves state associated with this page in case the application is suspended or the
            page is discarded from the navigation cache.  Values must conform to the serialization
            requirements of <see cref="P:StyleMVVM.Suspension.SuspensionManager.SessionState"/>.
            </summary>
            <param name="pageState">An empty dictionary to be populated with serializable state.</param>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwareUserControl.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:StyleMVVM.View.LayoutAwarePage"/> class.
            </summary>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwareUserControl.CoreDispatcher_AcceleratorKeyActivated(Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs)">
            <summary>
            Invoked on every keystroke, including system keys such as Alt key combinations, when
            this page is active and occupies the entire window.  Used to detect keyboard navigation
            between pages even when the page itself doesn't have focus.
            </summary>
            <param name="sender">Instance that triggered the event.</param>
            <param name="args">Event data describing the conditions that led to the event.</param>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwareUserControl.CoreWindow_PointerPressed(Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs)">
            <summary>
            Invoked on every mouse click, touch screen tap, or equivalent interaction when this
            page is active and occupies the entire window.  Used to detect browser-style next and
            previous mouse button clicks to navigate between pages.
            </summary>
            <param name="sender">Instance that triggered the event.</param>
            <param name="args">Event data describing the conditions that led to the event.</param>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwareUserControl.StartLayoutUpdates(System.Object,Windows.UI.Xaml.RoutedEventArgs)">
            <summary>
            Invoked as an event handler, typically on the <see cref="E:Windows.UI.Xaml.FrameworkElement.Loaded"/>
            event of a <see cref="T:Windows.UI.Xaml.Controls.Control"/> within the page, to indicate that the sender should
            start receiving visual state management changes that correspond to application view
            state changes.
            </summary>
            <param name="sender">Instance of <see cref="T:Windows.UI.Xaml.Controls.Control"/> that supports visual state
            management corresponding to view states.</param>
            <param name="e">Event data that describes how the request was made.</param>
            <remarks>The current view state will immediately be used to set the corresponding
            visual state when layout updates are requested.  A corresponding
            <see cref="E:Windows.UI.Xaml.FrameworkElement.Unloaded"/> event handler connected to
            <see cref="M:StyleMVVM.View.LayoutAwareUserControl.StopLayoutUpdates(System.Object,Windows.UI.Xaml.RoutedEventArgs)"/> is strongly encouraged.  Instances of
            <see cref="T:StyleMVVM.View.LayoutAwarePage"/> automatically invoke these handlers in their Loaded and
            Unloaded events.</remarks>
            <seealso cref="M:StyleMVVM.View.LayoutAwareUserControl.DetermineVisualState(Windows.UI.ViewManagement.ApplicationViewState)"/>
            <seealso cref="M:StyleMVVM.View.LayoutAwareUserControl.InvalidateVisualState"/>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwareUserControl.StopLayoutUpdates(System.Object,Windows.UI.Xaml.RoutedEventArgs)">
            <summary>
            Invoked as an event handler, typically on the <see cref="E:Windows.UI.Xaml.FrameworkElement.Unloaded"/>
            event of a <see cref="T:Windows.UI.Xaml.Controls.Control"/>, to indicate that the sender should start receiving
            visual state management changes that correspond to application view state changes.
            </summary>
            <param name="sender">Instance of <see cref="T:Windows.UI.Xaml.Controls.Control"/> that supports visual state
            management corresponding to view states.</param>
            <param name="e">Event data that describes how the request was made.</param>
            <remarks>The current view state will immediately be used to set the corresponding
            visual state when layout updates are requested.</remarks>
            <seealso cref="M:StyleMVVM.View.LayoutAwareUserControl.StartLayoutUpdates(System.Object,Windows.UI.Xaml.RoutedEventArgs)"/>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwareUserControl.DetermineVisualState(Windows.UI.ViewManagement.ApplicationViewState)">
            <summary>
            Translates <see cref="T:Windows.UI.ViewManagement.ApplicationViewState"/> values into strings for visual state
            management within the page.  The default implementation uses the names of enum values.
            Subclasses may override this method to control the mapping scheme used.
            </summary>
            <param name="viewState">View state for which a visual state is desired.</param>
            <returns>Visual state name used to drive the
            <see cref="T:Windows.UI.Xaml.VisualStateManager"/></returns>
            <seealso cref="M:StyleMVVM.View.LayoutAwareUserControl.InvalidateVisualState"/>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwareUserControl.InvalidateVisualState">
            <summary>
            Updates all controls that are listening for visual state changes with the correct
            visual state.
            </summary>
            <remarks>
            Typically used in conjunction with overriding <see cref="M:StyleMVVM.View.LayoutAwareUserControl.DetermineVisualState(Windows.UI.ViewManagement.ApplicationViewState)"/> to
            signal that a different value may be returned even though the view state has not
            changed.
            </remarks>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwareUserControl.LoadState(System.Object,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Populates the page with content passed during navigation.  Any saved state is also
            provided when recreating a page from a prior session.
            </summary>
            <param name="navigationParameter">The parameter value passed to
            <see cref="M:Windows.UI.Xaml.Controls.Frame.Navigate(System.Type,System.Object)"/> when this page was initially requested.
            </param>
            <param name="pageState">A dictionary of state preserved by this page during an earlier
            session.  This will be null the first time a page is visited.</param>
        </member>
        <member name="M:StyleMVVM.View.LayoutAwareUserControl.SaveState(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Preserves state associated with this page in case the application is suspended or the
            page is discarded from the navigation cache.  Values must conform to the serialization
            requirements of <see cref="!:SuspensionManager.SessionState"/>.
            </summary>
            <param name="pageState">An empty dictionary to be populated with serializable state.</param>
        </member>
        <member name="T:StyleMVVM.View.StartPageAttribute">
            <summary>
            This attribute is meant to be applied to a Page that is supposed to start the application
            </summary>
        </member>
    </members>
</doc>
